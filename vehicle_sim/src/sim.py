#!/usr/bin/python3

from datetime import datetime, timezone
import math
import numpy as np
import rospy
import tf
import utm

from geometry_msgs.msg import PoseStamped, TwistStamped
from geometry_utils.geometry_utils import compute_steering_angle_from_curvature, State
from nmea_msgs.msg import Gprmc
from std_msgs.msg import Float64
from vehicle_sim import LateralModel, LongitudinalModel, VehicleSim


class Sim:
    def __init__(self):

        # Constants
        rate = rospy.get_param("~rate", 10.0)
        self.time_step_secs = rospy.get_param(
            "~time_step_secs", 0.1
        )  # Ideally calculate that from rate above
        desired_acc_gain_p = rospy.get_param("~desired_acc_gain_p", 0.5)
        wheelbase = rospy.get_param("~wheelbase", 0.406)
        max_radius = rospy.get_param("~max_radius", 1000)
        self.mps_to_knots = 1.94384

        # Subscribers
        rospy.Subscriber(
            "initialpose",
            PoseStamped,
            self.clicked_point_callback,
        )
        rospy.Subscriber(
            "target_velocity",
            TwistStamped,
            self.target_velocity_callback,
        )
        rospy.Subscriber(
            "target_curvature",
            Float64,
            self.target_curvature_callback,
        )

        # Publishers
        self.sim_pose_pub = rospy.Publisher(
            "current_pose_sim",
            PoseStamped,
            queue_size=10,
        )
        self.sim_twist_pub = rospy.Publisher(
            "current_velocity_sim",
            TwistStamped,
            queue_size=10,
        )
        self.rmc_pub = rospy.Publisher("gps_info", Gprmc, queue_size=10)

        # Initialization
        self.simulated_vehicle = VehicleSim(
            lateral_model=LateralModel.PERFECT,
            longitudinal_model=LongitudinalModel.ACC_P_CONTROl,
            wheelbase_m=wheelbase,
            desired_acc_gain_p=desired_acc_gain_p,
        )

        self.state_initialized = False
        self.target_curvature = float(1 / max_radius)
        self.target_velocity = 0
        self.listener = tf.TransformListener()
        self.rate = rospy.Rate(rate)

    def clicked_point_callback(self, msg: PoseStamped):
        """
        Callback function to initialize the position and velocity of simulated vehicle when a clicked_point topic is published
        """

        rospy.logwarn("Clicked point callback")

        # Convert the coordinates from the map to the world frame.
        try:
            (trans, rot) = self.listener.lookupTransform("world", "map", rospy.Time(0))

            orientation_list = [
                msg.pose.orientation.x,
                msg.pose.orientation.y,
                msg.pose.orientation.z,
                msg.pose.orientation.w,
            ]
            (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(
                orientation_list
            )

            # Initialize the position and orientation using the position of the clicked point
            self.simulated_vehicle.current_state.x = msg.pose.position.x + trans[0]
            self.simulated_vehicle.current_state.y = msg.pose.position.y + trans[1]
            self.simulated_vehicle.current_state.angle = yaw

            # Initialize the speed to zero
            self.simulated_vehicle.current_state.vx = 0

            self.state_initialized = True

        except (
            tf.LookupException,
            tf.ConnectivityException,
            tf.ExtrapolationException,
        ):
            rospy.logwarn("Error during coordinate transform")

    def target_velocity_callback(self, msg: TwistStamped):
        """
        Target velocity callback, generated by the rest of the AV stack
        """
        self.target_velocity = msg.twist.linear.x

    def target_curvature_callback(self, msg: Float64):
        """
        Target curvature callback, generated by the rest of the AV stack
        """
        self.target_curvature = msg.data

    def loop(self):
        """
        Main loop of the vehicle simulator
        """

        while not rospy.is_shutdown():

            # If initial state has not been initialized
            if not self.state_initialized:
                rospy.loginfo("Sim has not started.")

            else:

                # Compute steering input
                steering_input = compute_steering_angle_from_curvature(
                    self.target_curvature, self.simulated_vehicle.wheelbase_m
                )

                # Predict next position given steering input
                self.simulated_vehicle.predict_next_pose(
                    steering_input, self.time_step_secs
                )

                # Predict next velocity based on longitudinal control model
                self.simulated_vehicle.predict_next_velocity(
                    self.target_velocity, self.time_step_secs
                )

                # Publish current simluated state for debugging
                self.publish_sim_state(self.simulated_vehicle.current_state)

                # Publish Gprmc topic
                self.publish_nmea_sentence(self.simulated_vehicle.current_state)

                # Convert position and velocity to NMEA sentence
                # sentence = self.nmea.create_sentence_string_from_state(self.simulated_vehicle.current_state)

                # Publish sentence on serial
                # self.serial_output.write(sentence)

            self.rate.sleep()

    def publish_sim_state(self, current_state: State) -> None:
        """
        Function to publish the vehicle's current position and velocity
        Argument:
            - state [State]: Current state of vehicle sim
        """

        """ Current position """
        pose_msg = PoseStamped()
        pose_msg.header.frame_id = "world"
        pose_msg.header.stamp = rospy.Time.now()
        pose_msg.pose.position.x = current_state.x
        pose_msg.pose.position.y = current_state.y

        quaternion = tf.transformations.quaternion_from_euler(0, 0, current_state.angle)
        pose_msg.pose.orientation.x = quaternion[0]
        pose_msg.pose.orientation.y = quaternion[1]
        pose_msg.pose.orientation.z = quaternion[2]
        pose_msg.pose.orientation.w = quaternion[3]

        self.sim_pose_pub.publish(pose_msg)

        """ Current velocity """
        twist_msg = TwistStamped()
        twist_msg.header.frame_id = "world"
        twist_msg.header.stamp = rospy.Time.now()
        twist_msg.twist.linear.x = current_state.vx

        self.sim_twist_pub.publish(twist_msg)

    def publish_nmea_sentence(self, current_state: State):
        """
        Function to publish the topic Gprmc topic
        Argument:
            - state [State]: Current state of vehicle sim
        """

        # Compute latitude and longitude from UTM coordinates
        zone_number = 10
        zone_letter = "S"
        latitude, longitude = utm.to_latlon(
            current_state.x, current_state.y, zone_number, zone_letter
        )

        # Current time
        now = datetime.now(timezone.utc)
        utc_seconds = now.second + now.microsecond / 1000000
        date = "%s-%s-%s" % (now.year, now.month, now.day)

        # Track angle
        track_angle_deg = ((math.pi / 2) - current_state.angle) * 180 / np.pi

        # Speed
        speed_knots = current_state.vx * self.mps_to_knots

        msg = Gprmc()
        msg.header.stamp = rospy.Time.now()
        msg.utc_seconds = utc_seconds
        msg.lat = latitude
        msg.lon = longitude
        msg.lat_dir = "N"
        msg.lon_dir = "W"
        msg.speed = speed_knots
        msg.track = track_angle_deg
        msg.date = date
        msg.mag_var = -1
        msg.mag_var_direction = ""
        msg.mode_indicator = "A"

        self.rmc_pub.publish(msg)


if __name__ == "__main__":
    try:
        rospy.init_node("Sim")
        sim = Sim()
        sim.loop()
    except rospy.ROSInterruptException:
        sim.ser.close()
        pass
